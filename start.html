<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Pool Game</title>
    <style>
        body {
            height: 100vh;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: whitesmoke;
            font-family: 'Franklin Gothic Medium', 'Arial Narrow', Arial, sans-serif;
            color: white;
        }
        #gameHeader {
            text-align: center;
        }
        #gameBoard {
            display: flex;
            width: 90vw;
            height: 75vh;
            box-shadow: 0px 0px 10px #000000;
            align-items: center;
            background-color: rgb(197, 196, 198);
        }
        .participantInfo {
            padding: 15px;
            flex: 1;
            text-align: center;
        }
        #poolTableContainer {
            display: flex;
            justify-content: center;
            align-items: center;
            transform: scale(0.4);
        }
        #cueOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 999;
            pointer-events: none;
        }
        .cueLine {
            stroke: black;
            stroke-width: 4;
            pointer-events: none;
            z-index: 1000;
        }
        #poolGameTitle {
            color: black !important;
        }
    </style>
</head>
<body>
    <div id="gameHeader">
        <h1 id="poolGameTitle"></h1>
    </div>
    <div id="gameBoard">
        <div id="playerOne" class="participantInfo">
            <p id="statusPlayerOne"></p>
            <h3 id="namePlayerOne"></h3>
            <bold>Score:</bold>
            <p id="scorePlayerOne"></p>
        </div>
        <div id="poolTableContainer">
            <!-- SVG Pool Table will be injected here -->
        </div>
        <div id="playerTwo" class="participantInfo">
            <p id="statusPlayerTwo"></p>
            <h3 id="namePlayerTwo"></h3>
            <bold>Score:</bold>
            <p id="scorePlayerTwo"></p>
        </div>

        <svg id="cueOverlay"></svg>

    </div>
</body>
<script>
    let id = '{id}'
    let targetBall;
    let aimLine;
    let isAiming = false;
    let horizontalSpeed, verticalSpeed;


// Function to handle the aiming mechanism
function activateAim() {
    // If not in aiming mode, exit the function
    if (!isAiming) {
        return;
    } else {
        // Get the overlay element for displaying the cue line
        const overlay = document.getElementById('cueOverlay');
        // Get the left and top positions of the overlay element
        let overlayLeft = overlay.getBoundingClientRect().left;
        let overlayTop = overlay.getBoundingClientRect().top;
        // Get the bounding rectangle of the target ball
        const ballRect = targetBall.getBoundingClientRect();
        // Calculate the center coordinates of the ball
        const ballCenterX = (ballRect.width / 2) + ballRect.left;
        const ballCenterY = (ballRect.height / 2) + ballRect.top;

        // Calculate the ball's position relative to the overlay
        const ballPosX = ballCenterX - overlayLeft;
        const ballPosY = ballCenterY - overlayTop;
        
        // Create a point to represent the cursor's position
        const cursorPoint = overlay.createSVGPoint();
        cursorPoint.x = event.clientX;
        cursorPoint.y = event.clientY;

        // Transform the cursor position to the overlay's coordinate system
        let cursorPos = cursorPoint.matrixTransform(overlay.getScreenCTM().inverse());

        // Calculate the difference in position between the ball center and the cursor
        let deltaX = ballCenterX - cursorPoint.x;
        let deltaY = ballCenterY - cursorPoint.y;

        // Calculate the speed of the shot based on the position differences
        horizontalSpeed = deltaX * 10;
        verticalSpeed = deltaY * 10;

        // Clamp the speed values to ensure they are within a reasonable range
        horizontalSpeed = Math.min(4000, Math.max(-4000, horizontalSpeed));
        verticalSpeed = Math.min(4000, Math.max(-4000, verticalSpeed));

        // Calculate the distance between the ball center and the cursor
        let distance = Math.sqrt((deltaX * deltaX) + (deltaY * deltaY));

        // If the distance is greater than 120, scale it down proportionally
        if (distance > 120) {
            let scale = 120 / distance;
            deltaX = scale * deltaX;
            deltaY = scale * deltaY;
        }

        // If the aiming line does not exist, create a new SVG line element for it
        if (!aimLine) {
            aimLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            aimLine.setAttribute('class', 'cueLine');
            overlay.appendChild(aimLine);
        }

        // Set the attributes of the aiming line to draw it from the ball center to the cursor
        aimLine.setAttribute('x1', ballCenterX);
        aimLine.setAttribute('y1', ballCenterY);
        aimLine.setAttribute('x2', ballCenterX - deltaX);
        aimLine.setAttribute('y2', ballCenterY - deltaY);
    }
}


// Function to initiate the aiming phase
function initiateAim() {
    // Set aiming flag to true indicating the user is now in aiming mode
    isAiming = true;
    // Change the cursor style to 'grab' to indicate that the user can now aim
    document.body.style.cursor = isAiming ? 'grab' : 'default';
    
    // Add an event listener for mouse movement to track the aiming direction
    document.addEventListener('mousemove', activateAim);
    // Add an event listener for mouse button release to end the aiming phase
    document.addEventListener('mouseup', endAim);
}


 // Function to handle the end of aiming phase
function endAim() {
    // Set aiming flag to false indicating the user is no longer aiming
    isAiming = false;
    // Change the cursor style to default since aiming has ended
    document.body.style.cursor = isAiming ? 'grab' : 'default';
    
    // Remove the event listener for mouse movement which was tracking the aim direction
    document.removeEventListener('mousemove', activateAim);
    // Remove the event listener for mouse button release which ends the aiming
    document.removeEventListener('mouseup', endAim);
    
    // Check if the aiming line is currently being displayed
    if (aimLine) {
        // Clear the cue overlay where the aim line was being drawn
        document.getElementById('cueOverlay').innerHTML = "";
        // Reset the aiming line variable to null
        aimLine = null;
        // Trigger the shot animation function which handles the shot execution and animation
        triggerShotAnimation();
    }
}



    function initializeENV() {
        isAiming = false;

        aimLine = null;

        svgTable = document.getElementById('gameSVG');

        targetBall = svgTable.querySelector('circle[fill="WHITE"]');

        if (targetBall) {
            targetBall.addEventListener('mousedown', initiateAim);
        } else {
            console.error("Ball not found.");
        }
    }

    function triggerShotAnimation() {
        const httpRequest = new XMLHttpRequest();
        httpRequest.onreadystatechange = function() {
            if (this.readyState === XMLHttpRequest.DONE) {
                if (this.status === 200) {
                    try {
                        // Attempt to parse the server response
                        const animationFrames = JSON.parse(this.responseText);
                        // If successful, start animating the SVG frames
                        runSVGAnimation(animationFrames, gameStatus);
                    } catch (parseError) {
                        // Log and handle any parsing error
                        console.error("Error parsing", parseError);
                        gameStatus(initializeENV);
                    }
                } else {
                    // Log if there's an error with the HTTP request
                    console.error("Error: Shot request failed", this.statusText);
                }
            }
        };
        httpRequest.open("POST", "/executeShot", true);
        httpRequest.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
        httpRequest.send("id=" + encodeURIComponent(id) + "&velocityX=" + encodeURIComponent(horizontalSpeed) + "&velocityY=" + encodeURIComponent(verticalSpeed));
    }

    // Animates SVG frames sequentially
    function runSVGAnimation(frameData, onComplete) {
        let frameIndex = 0;

        function displayNextFrame() {
            const svgDisplayArea = document.getElementById('poolTableContainer');

            svgDisplayArea.innerHTML = '';

            // Load and display the current frame
            const currentFrame = frameData[frameIndex];
            svgDisplayArea.innerHTML = currentFrame;
            frameIndex++;

            // Continue to the next frame if available
            if (frameIndex < frameData.length) {
                setTimeout(displayNextFrame, 1); // Proceed to next frame
            } else if (onComplete) {
                // If all frames are displayed, call the completion handler
                onComplete(initializeENV);
            }
        }

        // Initiate the frame display sequence
        displayNextFrame();
    }

    function updateElement(id, gamestat) {
        const element = document.getElementById(id);
        element.innerHTML = "";
        element.innerHTML = gamestats[gamestat];
    }



// Function to request and update the game status, then execute a callback if provided
function gameStatus(callback) {
    // Create a new XMLHttpRequest object to communicate with the server
    let request = new XMLHttpRequest();

    // Define a function to be called when the readyState of the request changes
    request.onreadystatechange = function() {
        // Check if the request is complete (readyState 4)
        if (this.readyState === XMLHttpRequest.DONE) {
            // Check if the request was successful (status 200)
            if (this.status === 200) {
                // Parse the JSON response text to a JavaScript object
                let gameInfo = JSON.parse(this.responseText);

                // Update the inner HTML of the 'poolTableContainer' element with the SVG content of the pool table
                document.getElementById('poolTableContainer').innerHTML = gameInfo.svg;
                // Update the inner HTML of the 'poolGameTitle' element with the game name
                document.getElementById('poolGameTitle').innerHTML = gameInfo.gameName;
                // Update the inner HTML of the 'namePlayerOne' element with the first player's name
                document.getElementById('namePlayerOne').innerHTML = gameInfo.p1Name;
                // Update the inner HTML of the 'namePlayerTwo' element with the second player's name
                document.getElementById('namePlayerTwo').innerHTML = gameInfo.p2Name;
                // Update the inner HTML of the 'statusPlayerOne' element with the play status of the first player
                document.getElementById('statusPlayerOne').innerHTML = gameInfo.p1Play;
                // Update the inner HTML of the 'statusPlayerTwo' element with the play status of the second player
                document.getElementById('statusPlayerTwo').innerHTML = gameInfo.p2Play;
                // Update the inner HTML of the 'scorePlayerOne' element with the score of the first player
                document.getElementById('scorePlayerOne').innerHTML = gameInfo.p1Score;
                // Update the inner HTML of the 'scorePlayerTwo' element with the score of the second player
                document.getElementById('scorePlayerTwo').innerHTML = gameInfo.p2Score;

                // If a callback function is provided, execute it
                if (callback) {
                    callback();
                }
            } else {
                // Log an error message if the request failed
                console.error("Failed to retrieve game status:", this.statusText);
            }
        }
    };
    
    // Initialize the request by specifying the HTTP method (GET), the URL, and setting async to true
    request.open("GET", `/gameStatus?id=${encodeURIComponent(id)}`, true);

    // Send the request to the server
    request.send();
}


    // Invoke gameStatus with initialization callback
    gameStatus(initializeENV);

</script>
</html>
