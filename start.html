<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Interactive Pool Game</title>
    <style>
        body {
            height: 100vh;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: whitesmoke;
            font-family: 'Franklin Gothic Medium', 'Arial Narrow', Arial, sans-serif;
            color: white;

        }
        #gameHeader {
            text-align: center;
        }
        #gameBoard {
            display: flex;
            width: 90vw;
            height: 75vh;
            box-shadow: 0px 0px 10px #000000;
            align-items: center;
            background-color: blueviolet;
        }
        .participantInfo {
            padding: 15px;
            flex: 1;
            text-align: center;
        }
        #poolTableContainer {
            display: flex;
            justify-content: center;
            align-items: center;
            transform: scale(0.4);
        }
        #cueOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 999;
            pointer-events: none;
        }
        .cueLine {
            stroke: black;
            stroke-width: 4;
            pointer-events: none;
            z-index: 1000;
        }
        #poolGameTitle {
            color: blueviolet !important;
        }
    </style>
</head>
<body>
    <div id="gameHeader">
        <h1 id="poolGameTitle"></h1>
    </div>
    <div id="gameBoard">
        <div id="playerOne" class="participantInfo">
            <p id="statusPlayerOne"></p>
            <h3 id="namePlayerOne"></h3>
            <bold>Score:</bold>
            <p id="scorePlayerOne"></p>
        </div>
        <div id="poolTableContainer">
            <!-- SVG Pool Table will be injected here -->
        </div>
        <div id="playerTwo" class="participantInfo">
            <p id="statusPlayerTwo"></p>
            <h3 id="namePlayerTwo"></h3>
            <bold>Score:</bold>
            <p id="scorePlayerTwo"></p>
        </div>

        <svg id="cueOverlay"></svg>

    </div>
</body>
<script>
    let id = '{id}'
    let targetBall;
    let aimLine;
    let isAiming = false;
    let horizontalSpeed, verticalSpeed;

    function activateAim() {
        if (!isAiming) {
            return;
        } else {
            const overlay = document.getElementById('cueOverlay');
            let overlayLeft = overlay.getBoundingClientRect().left;
            let overlayTop = overlay.getBoundingClientRect().top;
            const ballRect = targetBall.getBoundingClientRect();
            const ballCenterX = (ballRect.width / 2) + ballRect.left;
            const ballCenterY = (ballRect.height / 2) + ballRect.top;

            const ballPosX = ballCenterX - overlayLeft;
            const ballPosY = ballCenterY - overlayTop;
            
            const cursorPoint = overlay.createSVGPoint();
            cursorPoint.x = event.clientX;
            cursorPoint.y = event.clientY;

            let cursorPos = cursorPoint.matrixTransform(overlay.getScreenCTM().inverse());

            let deltaX = ballCenterX - cursorPoint.x;
            let deltaY = ballCenterY - cursorPoint.y;

            horizontalSpeed = deltaX * 10;
            verticalSpeed = deltaY * 10;

            horizontalSpeed = Math.min(4000, Math.max(-4000, horizontalSpeed));
            verticalSpeed = Math.min(4000, Math.max(-4000, verticalSpeed));

            let distance = Math.sqrt((deltaX * deltaX) + (deltaY * deltaY));

            if (distance > 120) {
                let scale = 120 / distance;
                deltaX = scale * deltaX;
                deltaY = scale * deltaY;
            }

            if (!aimLine) {
                aimLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                aimLine.setAttribute('class', 'cueLine');
                overlay.appendChild(aimLine);
            }

            aimLine.setAttribute('x1', ballCenterX);
            aimLine.setAttribute('y1', ballCenterY);
            aimLine.setAttribute('x2', ballCenterX - deltaX);
            aimLine.setAttribute('y2', ballCenterY - deltaY);
        }
    }

    function initiateAim() {
        isAiming = true;
        document.body.style.cursor = isAiming ? 'grab' : 'default';
        document.addEventListener('mousemove', activateAim);
        document.addEventListener('mouseup', endAim);
    }

    function endAim() {
        isAiming = false;
        document.body.style.cursor = isAiming ? 'grab' : 'default';
        document.removeEventListener('mousemove', activateAim);
        document.removeEventListener('mouseup', endAim);
        if (aimLine) {
            document.getElementById('cueOverlay').innerHTML = "";
            aimLine = null;
            triggerShotAnimation()
        }
    }

    function initializeENV() {
        isAiming = false;

        aimLine = null;

        svgTable = document.getElementById('gameSVG');

        targetBall = svgTable.querySelector('circle[fill="WHITE"]');

        if (targetBall) {
            targetBall.addEventListener('mousedown', initiateAim);
        } else {
            console.error("Ball not found.");
        }
    }

    function triggerShotAnimation() {
        const httpRequest = new XMLHttpRequest();
        httpRequest.onreadystatechange = function() {
            if (this.readyState === XMLHttpRequest.DONE) {
                if (this.status === 200) {
                    try {
                        // Attempt to parse the server response
                        const animationFrames = JSON.parse(this.responseText);
                        // If successful, start animating the SVG frames
                        runSVGAnimation(animationFrames, gameStatus);
                    } catch (parseError) {
                        // Log and handle any parsing error
                        console.error("Error parsing", parseError);
                        gameStatus(initializeENV);
                    }
                } else {
                    // Log if there's an error with the HTTP request
                    console.error("Error: Shot request failed", this.statusText);
                }
            }
        };
        httpRequest.open("POST", "/executeShot", true);
        httpRequest.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
        httpRequest.send("id=" + encodeURIComponent(id) + "&velocityX=" + encodeURIComponent(horizontalSpeed) + "&velocityY=" + encodeURIComponent(verticalSpeed));
    }

    // Animates SVG frames sequentially
    function runSVGAnimation(frameData, onComplete) {
        let frameIndex = 0;

        function displayNextFrame() {
            const svgDisplayArea = document.getElementById('poolTableContainer');

            svgDisplayArea.innerHTML = '';

            // Load and display the current frame
            const currentFrame = frameData[frameIndex];
            svgDisplayArea.innerHTML = currentFrame;
            frameIndex++;

            // Continue to the next frame if available
            if (frameIndex < frameData.length) {
                setTimeout(displayNextFrame, 1); // Proceed to next frame
            } else if (onComplete) {
                // If all frames are displayed, call the completion handler
                onComplete(initializeENV);
            }
        }

        // Initiate the frame display sequence
        displayNextFrame();
    }

    function updateElement(id, gamestat) {
        const element = document.getElementById(id);
        element.innerHTML = "";
        element.innerHTML = gamestats[gamestat];
    }



    function gameStatus(callback) {
        let request = new XMLHttpRequest();
        request.onreadystatechange = function() {
            // Ready state 4 means the request is done.
            if (this.readyState === XMLHttpRequest.DONE) {
                // Status 200 means "OK"
                if (this.status === 200) {
                    // Successfully received response
                    let gameInfo = JSON.parse(this.responseText);

                    // Updating elements with received game information
                    document.getElementById('poolTableContainer').innerHTML = gameInfo.svg;
                    document.getElementById('poolGameTitle').innerHTML = gameInfo.gameName;
                    document.getElementById('namePlayerOne').innerHTML = gameInfo.p1Name;
                    document.getElementById('namePlayerTwo').innerHTML = gameInfo.p2Name;
                    document.getElementById('statusPlayerOne').innerHTML = gameInfo.p1Play;
                    document.getElementById('statusPlayerTwo').innerHTML = gameInfo.p2Play;
                    document.getElementById('scorePlayerOne').innerHTML = gameInfo.p1Score;
                    document.getElementById('scorePlayerTwo').innerHTML = gameInfo.p2Score;

                    // Execute callback if provided
                    if (callback) {
                        callback();
                    }
                } else {
                    // Handle potential errors
                    console.error("Failed to retrieve game status:", this.statusText);
                }
            }
        };
        
        // Setting up and sending the HTTP GET request
        request.open("GET", `/gameStatus?id=${encodeURIComponent(id)}`, true);
        request.send();
    }

    // Invoke gameStatus with initialization callback
    gameStatus(initializeENV);

</script>
</html>
